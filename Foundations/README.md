# Curriculum

**Curriculum version**: `1.0.0`

- [Prerequisites]()
- [Phase 1: Foundations (Core CS)]()
    - [Module 1: Programming Fundamentals](#module-1-programming-fundamentals)
    - [Module 2: Mathematical Foundations](#module-2-mathematical-foundations)
    - [Module 3: Foundational Systems](#module-3-foundational-systems)
    - [Module 4: Foundational Applications](#module-4-foundational-applications)
    - [Module 5: Fundamental Theory and Ethics](#module-5-fundamental-theory-and-ethics)


---

# **Module 1: Programming Fundamentals**

At this stage, it's time to begin your programming journey. In a structured bachelorâ€™s-equivalent Computer Science curriculum, programming is the foundation of everything you will learn moving forward.

## Choosing Your First Programming Language

Programming is the foundation of computer science, and mastering it will open doors to various fields such as web development, artificial intelligence, data science, cybersecurity, and more.

### Why Start with Python?

We recommend starting with Python as your first programming language because:

- âœ… **Beginner-Friendly:** Pythonâ€™s syntax is simple, clean, and resembles English, making it easy to read and write.
- âœ… **Widely Used in Industry:** Python is used in AI, machine learning, web development, automation, data science, cybersecurity, and more.
- âœ… **Strong Community Support:** Python has one of the largest programming communities, meaning plenty of resources, tutorials, and support are available.
- âœ… **Faster Learning Curve:** Unlike languages like C++ or Java, Python lets you focus on learning programming concepts rather than complex syntax.

### What You Will Learn in This Module

By the end of this module, you will be able to:

- Write and debug Python code using variables, data types, operators, control flow structures (if/else, loops), and functions.
- Design and implement object-oriented programs using classes, objects, inheritance, and polymorphism.
- Work with common data structures such as lists, dictionaries, tuples, and sets.
- Read and write data to files and handle exceptions effectively.
- Implement basic algorithms for searching and sorting.
- Apply software engineering principles such as version control (Git) and code reviews.
- Design programs following systematic and class-based design principles.
- Understand and apply functional programming concepts.
- Implement unit tests for your code.

### Why Python First? What About Other Languages?

Starting with Python gives you a strong foundation in programming concepts, making it easier to learn other languages like JavaScript, Java, C++, and Go in the future. Once youâ€™re comfortable with Python, learning another language mostly involves understanding syntax differences and specific features rather than learning programming from scratch.

ðŸš€ **Final Recommendation:** Start with Python to build a strong programming foundation. As you progress in OpenCS, you will also get exposure to other important languages such as JavaScript, C++, and Go, depending on your specialization.

## Courses in this Module

This module is designed to give you both a broad introduction to programming and a deep dive into software design principles.Â  It incorporates courses from MIT and other sources to provide a well-rounded learning experience. OpenCS recommends dedicating at least 6 hours a day (36 hours a week) to your studies for optimal progress.

### Course 1: Introduction to CS and Programming using Python (MIT OpenCourseWare)

This course is aimed at students with little to no programming experience. It aims to provide students with an understanding of the role computation can play in solving problems. It also aims to help students, regardless of their major, feel justifiably confident in their ability to write simple programs that allow them to accomplish useful goals. The class will use the Python 3 programming language.

- **Effort:** 8-10 hours/week
- **Prerequisites:** None
- **Resources:** [Introduction to Computation and Programming Using Python](http://repo.darmajaya.ac.id/5070/1/Introduction%20to%20Computation%20and%20Programming%20Using%20Python%20by%20John%20V.%20Guttag%20%28z-lib.org%29.pdf)
- **Discussion:** [Course 1 Discussion Forum]()Â *(Create a link to your discussion forum)*
- **Link:** [Course 1: Introduction to CS and Programming using Python By MIT](https://ocw.mit.edu/courses/6-100l-introduction-to-cs-and-programming-using-python-fall-2022/pages/material-by-lecture/)
- **Mastery Hours:** Up to 100 hours. Mastery hours are optional and intended for students who wish to explore topics in greater depth, work on additional projects, or delve into advanced concepts.

### Course 2: The Missing Semester of Your CS Education

Classes teach you all about advanced topics within CS, from operating systems to machine learning, but thereâ€™s one critical subject thatâ€™s rarely covered, and is instead left to students to figure out on their own: proficiency with their tools. Weâ€™ll teach you how to master the command-line, use a powerful text editor, use fancy features of version control systems, and much more!

Students spend hundreds of hours using these tools over the course of their education (and thousands over their career), so it makes sense to make the experience as fluid and frictionless as possible. Mastering these tools not only enables you to spend less time on figuring out how to bend your tools to your will, but it also lets you solve problems that would previously seem impossibly complex.

- **Effort:** 2 weeks (12 hours/week recommended)
- **Prerequisites:** None
- **Discussion:** [The Missing Semester Discussion Forum]() _(Create a link)_
- **Link:** [The Missing Semester of Your CS Education](https://missing.csail.mit.edu/)
- **Mastery Hours:** Up to 40 hours.

### Course 3: Advancing Beyond Core Programming in OpenCS

This course builds upon the foundational programming concepts covered in the previous courses and delves into software design principles, advanced programming techniques, and exposure to different programming paradigms.Â  It draws inspiration from OSSU (Open Source Society University) to provide a deep, structured, and practical approach to programming.

- **Effort:** Varies by sub-course (see below)
- **Prerequisites:** Courses 1 and 2
- **Discussion:** [Module 1 Discussion Forum]() _(Create a link)_
- **Mastery Hours:** Varies by sub-course (see below)

#### Sub-Courses:

- **Systematic Program Design:** (13 weeks) \[Link to [https://learning.edx.org/course/course-v1:UBCx+SPD1x+2T2015](https://learning.edx.org/course/course-v1:UBCx+SPD1x+2T2015)] Mastery Hours: Up to 80 hours.
- **Class-based Program Design:** (5-10 hours/week) \[Link to: [https://course.ccs.neu.edu/cs2510sp22/index.html](https://course.ccs.neu.edu/cs2510sp22/index.html)] Mastery Hours: Up to 60 hours.
- **Programming Languages, Part A:** (4-8 hours/week) \[Link to: [https://www.coursera.org/learn/programming-languages](https://www.coursera.org/learn/programming-languages)] Mastery Hours: Up to 50 hours.
- **Programming Languages, Part B:** (4-8 hours/week) \[Link to: [https://www.coursera.org/learn/programming-languages-part-b](https://www.coursera.org/learn/programming-languages-part-b)] Mastery Hours: Up to 40 hours.
- **Programming Languages, Part C:** (4-8 hours/week) \[Link to: [https://www.coursera.org/learn/programming-languages-part-c](https://www.coursera.org/learn/programming-languages-part-c)] Mastery Hours: Up to 40 hours.
- **Object-Oriented Design:** (5-10 hours/week) \[Link to: [https://course.ccs.neu.edu/cs3500f19/](https://course.ccs.neu.edu/cs3500f19/)] Mastery Hours: Up to 60 hours.
- **Software Architecture:** (2-5 hours/week) \[Link to: [https://www.coursera.org/learn/software-architecture](https://www.coursera.org/learn/software-architecture)] Mastery Hours: Up to 30 hours.

# **Module 2: Mathematical Foundations**

Congratulations on completing Module 1! You've now built a solid foundation in programming. This module dives into the essential mathematical concepts that underpin computer science. Mastering these concepts will give you a significant advantage, setting you apart from those who focus solely on coding.

As you've discovered, CS is not just about writing code. It's about understanding the _why_ behind the code â€“ the logic, the efficiency, the limitations. Mathematics provides the tools to analyze problems, design algorithms, and reason about computation. Many people jump directly into applied areas like AI/ML, Web Dev, Game Dev, or Cybersecurity, but a strong mathematical foundation is what truly distinguishes a computer scientist and allows you to deeply understand and innovate in those fields. It's an investment that pays off exponentially.

## Why Study Mathematics for Computer Science?

A solid understanding of mathematics is crucial for success in computer science. It empowers you to:

- **Design Efficient Algorithms:** Mathematics, particularly discrete math and linear algebra, provides the tools to analyze the efficiency of algorithms (time and space complexity) and design better ones.
- **Reason about Data:** Probability and statistics are essential for data analysis, machine learning, and understanding the behavior of complex systems.
- **Understand Computer Systems:** Boolean algebra, logic, and discrete math are fundamental to computer architecture, digital logic design, and network protocols.
- **Tackle Complex Problems:** Mathematical thinking cultivates problem-solving skills that are applicable to a wide range of CS challenges.
- **Innovate and Create:** A strong mathematical foundation allows you to go beyond simply applying existing tools and enables you to develop new ones.

## What You Will Learn in This Module

This module covers the essential mathematical concepts needed for a strong foundation in computer science, including:

- **Calculus:** Provides the foundation for mathematical maturity and prepares you for more advanced topics.
- **Discrete Mathematics:** The backbone of computer science, covering logic, set theory, graph theory, combinatorics, and proof techniques.
- **Probability and Statistics:** Essential for understanding data analysis, machine learning, and dealing with uncertainty.

## Courses in This Module

This module incorporates courses from MIT to provide a rigorous and comprehensive learning experience. We encourage you to dedicate significant time to mastering these concepts. Don't just solve the problems; strive to deeply understand the underlying principles. Consider working through supplementary materials and practice problems to solidify your knowledge.

### Course 4: Calculus Series (MIT OpenCourseWare)

This series of courses provides a solid foundation in calculus, which is essential for developing mathematical maturity and preparing for more advanced topics.

- **Calculus 1A: Differentiation:** (13 weeks) \[Link to: [https://openlearninglibrary.mit.edu/courses/course-v1:MITx+18.01.1x+2T2019/about](https://openlearninglibrary.mit.edu/courses/course-v1:MITx+18.01.1x+2T2019/about)]
  - **Prerequisites:** High school math
  - **Discussion:** \[Link to discussion forum]
- **Calculus 1B: Integration:** (13 weeks) \[Link to: [https://openlearninglibrary.mit.edu/courses/course-v1:MITx+18.01.2x+3T2019/about](https://openlearninglibrary.mit.edu/courses/course-v1:MITx+18.01.2x+3T2019/about)]
  - **Prerequisites:** Calculus 1A
  - **Discussion:** \[Link to discussion forum]
- **Calculus 1C: Coordinate Systems & Infinite Series:** (6 weeks) \[Link to: [https://openlearninglibrary.mit.edu/courses/course-v1:MITx+18.01.3x+1T2020/about](https://openlearninglibrary.mit.edu/courses/course-v1:MITx+18.01.3x+1T2020/about)]
  - **Prerequisites:** Calculus 1B
  - **Discussion:** \[Link to discussion forum]

### Course 5: Mathematics for Computer Science (MIT OpenCourseWare)

This course covers the essential discrete mathematics concepts needed for computer science.

- **Effort:** 13 weeks
- **Prerequisites:** Calculus 1C
- **Resources:** \[Link to: [https://openlearninglibrary.mit.edu/courses/course-v1:OCW+6.042J+2T2019/about](https://openlearninglibrary.mit.edu/courses/course-v1:OCW+6.042J+2T2019/about)] (Alternative: \[Link to: [https://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2010/](https://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2010/))]
- **Discussion:** \[Link to discussion forum]

## Supplementary Resources (Optional, but highly recommended)

To deepen your understanding and strengthen your problem-solving skills, consider working through these supplementary resources alongside the core courses:

- <p style="color:red"> (List any supplementary books or online resources you recommend)</p>

# **Module 3: Foundational Systems**

This module delves into the inner workings of computer systems, from the fundamental building blocks of hardware to the complex software that manages it. It covers computer architecture, operating systems, and computer networking.

## Why Study Foundational Systems?

Understanding these foundational concepts is essential for any serious computer scientist. It allows you to:

- **Write More Efficient Code:** Knowing how memory works, how processes are managed, and how networks function can help you write code that is optimized for performance.
- **Debug More Effectively:** When things go wrong (and they will!), understanding the underlying systems can help you diagnose and fix problems more quickly.
- **Design Better Systems:** Whether you're developing web applications, mobile apps, or embedded systems, a solid understanding of systems principles will enable you to design more robust and scalable systems.
- **Adapt to New Technologies:** The principles you learn in this module are applicable across a wide range of technologies. Even as new hardware and software emerge, the foundational concepts remain relevant.

## What You Will Learn in This Module

This module covers the essential systems concepts needed for a strong foundation in computer science, including:

- **Computer Architecture:** Understanding the organization and function of computer hardware components (CPU, memory, I/O).
- **Operating Systems:** Learning how operating systems manage hardware resources, handle processes, and provide services to applications.
- **Computer Networking:** Understanding how computers communicate with each other over networks.

## Programming Language for this Module

C is the recommended programming language for this module. It is essential for systems programming and working with low-level details of operating systems and hardware.

## Courses in This Module

This module incorporates highly regarded resources to provide a rigorous and comprehensive learning experience. We encourage you to dedicate significant time to mastering these concepts. Don't just complete the assignments; strive to deeply understand the underlying principles.

### Course 6: Build a Modern Computer from First Principles: From Nand to Tetris (Parts I & II)

This project-based learning experience allows you to build a computer from the ground up, starting with logic gates and ending with a working software hierarchy. It provides an unparalleled understanding of how hardware and software interact.

- **Effort:** 6 weeks (Part I), 6 weeks (Part II) - 7-13 hours/week (Part I), 12-18 hours/week (Part II)
- **Prerequisites:** A C-like programming language (C recommended)
- **Resources:** [Nand2Tetris Website](https://www.nand2tetris.org/) (Alternative: [Coursera Course](https://www.coursera.org/learn/build-a-computer), [Coursera Part II](https://www.coursera.org/learn/nand2tetris2))
- **Discussion:** \[Link to discussion forum]
- **Mastery Hours:** Up to 120 hours (combined for both parts).

### Course 7: Operating Systems: Three Easy Pieces

This classic book (and accompanying materials) provides a clear and concise explanation of the core concepts of operating systems.

- **Effort:** 10-12 weeks, 6-10 hours/week
- **Prerequisites:** Nand to Tetris Part II
- **Resources:** [Operating Systems: Three Easy Pieces](coursepages/ostep/README.md) _(Link to your course page)_
- **Discussion:** \[Link to discussion forum]
- **Mastery Hours:** Up to 100 hours.

### Course 8: Computer Networking: A Top-Down Approach

This widely used textbook provides a comprehensive introduction to computer networking. The "top-down" approach is effective for understanding how networks function at different layers. The inclusion of Wireshark Labs provides valuable practical experience.

- **Effort:** 8 weeks, 4â€“12 hours/week
- **Prerequisites:** Algebra, probability, basic CS knowledge
- **Resources:** [Computer Networking: A Top-Down Approach Online Lectures](http://gaia.cs.umass.edu/kurose_ross/online_lectures.htm), [Wireshark Labs](http://gaia.cs.umass.edu/kurose_ross/wireshark.php)
- **Discussion:** \[Link to discussion forum]
- **Mastery Hours:** Up to 80 hours.

# **Module 4: Foundational Applications**

This module bridges the gap between the foundational concepts (programming, math, systems) and real-world applications of computer science. It explores key areas like databases, machine learning, computer graphics, and software engineering.

## Why Study Foundational Applications?

This module is crucial because it:

- **Provides Context:** It shows students how the theoretical knowledge they've gained can be applied to solve real-world problems.
- **Develops Practical Skills:** Students gain hands-on experience working with databases, machine learning tools, graphics libraries, and software engineering methodologies.
- **Explores Career Paths:** Exposure to these different application areas can help students discover their interests and choose a specialization.
- **Reinforces Foundational Concepts:** Working on projects in these areas reinforces the programming, mathematical, and systems concepts learned in earlier modules.

## What You Will Learn in This Module

By the end of this module, you will be able to:

- **Databases:** Design and implement relational databases, write SQL queries, and understand database management principles.
- **Machine Learning:** Understand fundamental machine learning algorithms and apply them to real-world problems.
- **Computer Graphics:** Learn the basics of computer graphics, including 2D and 3D rendering and animation.
- **Software Engineering:** Apply software engineering principles to design, develop, and maintain software projects.

## Programming Languages for this Module

The choice of programming language for this module will depend on the specific courses and projects.

- **Databases:** SQL is essential. Python is commonly used for database interaction and data analysis.
- **Machine Learning:** Python is the dominant language due to its rich ecosystem of libraries.
- **Computer Graphics:** C++ is common due to performance. Python or JavaScript might be used depending on the course.
- **Software Engineering:** Python, Java, or other widely used languages are possible.


### Course 9: Databases

- **Databases: Modeling and Theory:** (2 weeks, 10 hours/week)
  - **Prerequisites:** Programming Fundamentals
  - **Resources:** \[Link to: [https://www.edx.org/course/modeling-and-theory](https://www.edx.org/course/modeling-and-theory)]
  - **Discussion:** \[Link to discussion forum]
  - **Mastery Hours:** Up to 40 hours
- **Databases: Relational Databases and SQL:** (2 weeks, 10 hours/week)
  - **Prerequisites:** Programming Fundamentals
  - **Resources:** \[Link to: [https://www.edx.org/course/databases-5-sql](https://www.edx.org/course/databases-5-sql)]
  - **Discussion:** \[Link to discussion forum]
  - **Mastery Hours:** Up to 40 hours
- **Databases: Semistructured Data:** (2 weeks, 10 hours/week)
  - **Prerequisites:** Programming Fundamentals
  - **Resources:** \[Link to: [https://www.edx.org/course/semistructured-data](https://www.edx.org/course/semistructured-data)]
  - **Discussion:** \[Link to discussion forum]
  - **Mastery Hours:** Up to 40 hours

### Course 10: Machine Learning

- **Machine Learning:** (11 weeks, 9 hours/week)
  - **Prerequisites:** Basic coding
  - **Resources:** \[Link to: [https://www.coursera.org/specializations/machine-learning-introduction](https://www.coursera.org/specializations/machine-learning-introduction)]
  - **Discussion:** \[Link to discussion forum]
  - **Mastery Hours:** Up to 100 hours

### Course 11: Computer Graphics

- **Computer Graphics:** (6 weeks, 12 hours/week)
  - **Prerequisites:** C++ or Java, linear algebra
  - **Resources:** \[Link to: [https://www.edx.org/course/computer-graphics-2](https://www.edx.org/course/computer-graphics-2)]
  - **Discussion:** \[Link to discussion forum]
  - **Mastery Hours:** Up to 80 hours

### Course 12: Software Engineering

- **Software Engineering: Introduction:** (6 weeks, 8-10 hours/week)
  - **Prerequisites:** Programming Fundamentals and Foundational Systems
  - **Resources:** \[Link to: [https://www.edx.org/learn/software-engineering/university-of-british-columbia-software-engineering-introduction](https://www.edx.org/learn/software-engineering/university-of-british-columbia-software-engineering-introduction)] (Alternative: \[Link to: [https://github.com/ubccpsc/310/blob/main/resources/README.md](https://github.com/ubccpsc/310/blob/main/resources/README.md)])
  - **Discussion:** \[Link to discussion forum]
  - **Mastery Hours:** Up to 80 hours

# **Module 5: Fundamental Theory and Ethics**

This module explores the theoretical foundations of computer science, including algorithms, computational complexity, and ethical considerations.  A strong understanding of these areas is crucial for developing a well-rounded perspective in computer science.

## Why Study Fundamental Theory and Ethics?

This module is essential because it:

*   **Deepens Understanding:**  It goes beyond simply *using* algorithms and data structures to understanding *why* they work and how to analyze their efficiency.
*   **Develops Critical Thinking:** Studying computational complexity and the limits of computation enhances critical thinking and problem-solving skills.
*   **Promotes Ethical Awareness:**  As technology becomes more integrated into our lives, it's crucial to understand the ethical implications of computer science and develop responsible practices.
*   **Prepares for Advanced Study:** The theoretical concepts covered in this module are essential for advanced study in areas like artificial intelligence, machine learning, and cryptography.

## What You Will Learn in This Module

By the end of this module, you will be able to:

*   **Algorithms:** Analyze the efficiency of algorithms using Big O notation, understand different algorithmic paradigms (divide and conquer, greedy, dynamic programming), and implement fundamental algorithms.
*   **Computational Complexity:** Understand the concepts of P and NP, and the limitations of computation.
*   **Ethics:**  Analyze the ethical implications of technology, understand intellectual property rights, and consider data privacy issues.


### Course 13: Algorithms and Computation

*   **Divide and Conquer, Sorting and Searching, and Randomized Algorithms:** (4 weeks)
    *   **Prerequisites:** Any programming language, Mathematics for Computer Science
    *   **Resources:** \[Link to: [https://www.coursera.org/learn/algorithms-divide-conquer](https://www.coursera.org/learn/algorithms-divide-conquer)]
    *   **Discussion:** \[Link to discussion forum]
    *   **Mastery Hours:** Up to 80 hours
*   **Graph Search, Shortest Paths, and Data Structures:** (4 weeks)
    *   **Prerequisites:** Divide and Conquer, Sorting and Searching, and Randomized Algorithms
    *   **Resources:** \[Link to: [https://www.coursera.org/learn/algorithms-graphs-data-structures](https://www.coursera.org/learn/algorithms-graphs-data-structures)]
    *   **Discussion:** \[Link to discussion forum]
    *   **Mastery Hours:** Up to 80 hours
*   **Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming:** (4 weeks)
    *   **Prerequisites:** Graph Search, Shortest Paths, and Data Structures
    *   **Resources:** \[Link to: [https://www.coursera.org/learn/algorithms-greedy](https://www.coursera.org/learn/algorithms-greedy)]
    *   **Discussion:** \[Link to discussion forum]
    *   **Mastery Hours:** Up to 80 hours
*   **Shortest Paths Revisited, NP-Complete Problems and What To Do About Them:** (4 weeks)
    *   **Prerequisites:** Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming
    *   **Resources:** \[Link to: [https://www.coursera.org/learn/algorithms-npcomplete](https://www.coursera.org/learn/algorithms-npcomplete)]
    *   **Discussion:** \[Link to discussion forum]
    *   **Mastery Hours:** Up to 80 hours

### Course 14: Ethics and Professionalism

*   **Ethics, Technology and Engineering:** (9 weeks)
    *   **Prerequisites:** None
    *   **Resources:** \[Link to: [https://www.coursera.org/learn/ethics-technology-engineering](https://www.coursera.org/learn/ethics-technology-engineering)]
    *   **Discussion:** \[Link to discussion forum]
    *   **Mastery Hours:** Up to 60 hours
*   **Introduction to Intellectual Property:** (4 weeks)
    *   **Prerequisites:** None
    *   **Resources:** \[Link to: [https://www.coursera.org/learn/introduction-intellectual-property](https://www.coursera.org/learn/introduction-intellectual-property)]
    *   **Discussion:** \[Link to discussion forum]
    *   **Mastery Hours:** Up to 40 hours
*   **Data Privacy Fundamentals:** (3 weeks)
    *   **Prerequisites:** None
    *   **Resources:** \[Link to: [https://www.coursera.org/learn/northeastern-data-privacy](https://www.coursera.org/learn/northeastern-data-privacy)]
    *   **Discussion:** \[Link to discussion forum]
    *   **Mastery Hours:** Up to 40 hours

